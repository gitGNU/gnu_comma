/*===-- runtime/crt_types.h -----------------------------------------------===
 *
 * This file is distributed under the MIT license. See LICENSE.txt for details.
 *
 * Copyright (C) 2009, Stephen Wilson
 *
 *===----------------------------------------------------------------------===*/

#ifndef COMMA_RUNTIME_CRT_TYPES_HDR_GUARD
#define COMMA_RUNTIME_CRT_TYPES_HDR_GUARD

#include <stddef.h>
#include <inttypes.h>

/*
 * The type of pointers to functions which a domain exports.
 */
typedef void (*export_fn_t)();

/*
 * Forward declaration of the instance table used to manage the construction of
 * domain instances (defined in crt_itable.h).
 */
struct itable;
typedef struct itable *itable_t;

/*
 * Forward declarations for the basic types defined herein.
 */
struct domain_view;
typedef struct domain_view *domain_view_t;

struct domain_instance;
typedef struct domain_instance *domain_instance_t;

struct domain_info;
typedef struct domain_info *domain_info_t;


/*
 * The type of pointers to domain constructors.
 */
typedef void (*domain_ctor_t)(domain_instance_t);

/*
 * For each domain definition the compiler emits a domain_info_t structure which
 * is associated with a global symbol pointing to the object.  The main use of
 * such a structure is to provide the information necessary to construct
 * instances of the domain in question.
 */
struct domain_info {

        /*
         * The number of arguments which this domain accepts.
         */
        uint32_t arity;

        /*
         * The number of super signatures this domain implements.
         */
        uint32_t num_signatures;

        /*
         * The name of this domain, as seen in the source code definition.
         */
        const char *name;

        /*
         * The constructor used to initialize instances of this domain.  If this
         * field is null, the domain does not require initialization.
         */
        domain_ctor_t ctor;

        /*
         * An itable mapping arrays of domain views (parameters) to specific
         * instances.  This is initially a null pointer when emitted by the
         * compiler.
         */
        itable_t instance_table;

        /*
         * An array with num_signatures entries giving offsets into the exports
         * vector corresponding to each super signature of this domain.
         */
        uint64_t *sig_offsets;

        /*
         * An array of exported functions, ordered so that each index
         * corresponds to the declaration order of the functions as given by a
         * depth-first preorder traversal of the signature hierarchy (duplicates
         * are not ignored here).
         */
        export_fn_t *exports;
};

/*
 * Represents a domain constrained to a particular signature.  These views
 * provide that portion of the implementing domains exports vector which
 * supplies the functions available thru a particular signature.
 */
struct domain_view {
        /*
         * The particular domain instance implementing this view.
         */
        domain_instance_t instance;

        /*
         * The signature index as understood by the implementing domain (its
         * DFPO index in the domains signature graph).
         */
        ptrdiff_t index;
};

/*
 * An actual instance of a domain, generated by calls to make_domain.  This is
 * the runtime representation of a domain.
 */
struct domain_instance {
        /*
         * Compiler generated information about this domain.
         */
        domain_info_t info;

        /*
         * Next pointer to support open chaining of hashed instances.
         */
        domain_instance_t next;

        /*
         * Actual parameters supplied to this domain, viewed thru the signature
         * constraint of the parameter.
         */
        domain_view_t *params;

        /*
         * A view of this instance for each super signature, in DFPO of the
         * signature graph.
         */
        struct domain_view *views;

        /*
         * The domains required by this instance.
         */
        domain_instance_t *requirements;
};

domain_instance_t alloc_domain_instance(domain_info_t info);

/*
 * Get a domain instance.
 */
domain_instance_t _comma_get_domain(domain_info_t info, ...);

#endif
