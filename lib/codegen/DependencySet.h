//===-- codegen/DependencySet.h ------------------------------- -*- C++ -*-===//
//
// This file is distributed under the MIT license. See LICENSE.txt for details.
//
// Copyright (C) 2009, Stephen Wilson
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
/// \file
///
/// \brief Defines the DependencySet class.
//===----------------------------------------------------------------------===//

#ifndef COMMA_CODEGEN_DEPENDENCYSET_HDR_GUARD
#define COMMA_CODEGEN_DEPENDENCYSET_HDR_GUARD

#include "llvm/ADT/UniqueVector.h"

#include <iterator>

namespace comma {

class DependencySet;
class DomainInstanceDecl;
class Domoid;

/// Iterator over the elements of a DependencySet.
class DependencySetIterator
    : public std::iterator<std::bidirectional_iterator_tag,
                           const DomainInstanceDecl*> {

    const DependencySet *DS;
    unsigned index;

    DependencySetIterator(const DependencySet *DS) : DS(DS), index(0) { }

    DependencySetIterator(const DependencySet *DS, unsigned index)
        : DS(DS), index(index) { }

    friend class DependencySet;

public:
    bool operator ==(const DependencySetIterator &iter) const {
        return (DS == iter.DS && index == iter.index);
    }

    bool operator !=(const DependencySetIterator &iter) const {
        return !(*this == iter);
    }

    DependencySetIterator &operator++() {
        index++;
        return *this;
    }

    DependencySetIterator operator++(int) {
        DependencySetIterator res = *this;
        index++;
        return res;
    }

    DependencySetIterator &operator--() {
        index--;
        return *this;
    }

    DependencySetIterator operator--(int) {
        DependencySetIterator res = *this;
        index--;
        return res;
    }

    const DomainInstanceDecl *operator*() const;

    const DomainInstanceDecl *operator->() const;
};

/// This class analyzes the given capsule and generates a dependency set.
///
/// A dependency set is the collection of all externally referenced domain
/// instances which a capsule references.  Moreover, the set is \em ordered such
/// that earlier instances do not depend on those which follow.  Each instance
/// is associated with a zero-based ID which can be used to index the set and
/// test the ordering relation.
///
/// The information generated by this class is used by the runtime to build
/// constructor functions (such functions need to elaborate the required domain
/// instances in the order provided by dependency sets.).
class DependencySet {

    typedef llvm::UniqueVector<const DomainInstanceDecl*> DependenceVector;

    const Domoid *capsule;
    DependenceVector dependents;

public:
    DependencySet(const Domoid *domoid) : capsule(domoid) { scan(); }

    typedef DependencySetIterator iterator;
    iterator begin() const { return DependencySetIterator(this); }
    iterator end() const { return DependencySetIterator(this, size()); }

    // Returns the capsule this dependency set represents.
    const Domoid *getCapsule() const { return capsule; }

    unsigned getDependentID(iterator I) const {
        return dependents.idFor(*I) - 1;
    }

    const DomainInstanceDecl *getDependent(unsigned ID) const {
        return dependents[ID + 1];
    }

    iterator find(const DomainInstanceDecl *instance) const;

    unsigned size() const { return dependents.size(); }

private:
    /// Scans the associated capsule and populates the dependents vector.
    void scan();
};

inline const DomainInstanceDecl *DependencySetIterator::operator*() const {
    return DS->getDependent(index);
}

inline const DomainInstanceDecl *DependencySetIterator::operator->() const {
    return DS->getDependent(index);
}

} // end comma namespace.

#endif
