##-- testsuite/lib/comma-dg.exp -----------------------------------*- Tcl -*--##
#
# This file is distributed under the MIT License.  See LICENSE.txt for details.
#
# Copyright (C) 2009, Stephen Wilson
#
##----------------------------------------------------------------------------##

#
# This function searches the input file for comment lines of the following form:
#
#   -- MUST-FAIL: <other stuff>
#
#   -- BUG: <other stuff>
#
# A MUST-FAIL comment indicates that a non-zero exit status of the test
# indicates a PASS.  And conversely, that a zero exit status indicates a FAIL.
# A MUST-FAIL test is used to ensure that the system is detecting erroneous
# input.
#
# A BUG comment indicates a known-bug.  A non-zero exit status from such a test
# indicates an XFAIL (meaning that the bug persists), whereas a zero exit status
# indicates an XPASS (meaning that the bug, in principle, no longer exists and
# that the test status should be updated).
#
# By default (meaning that the file does not provide such markup), zero and
# non-zero exit status represent PASS and FAIL respectively.
#
# This function returns "PASS", "MUST-FAIL", or "BUG" as appropriate.
#
proc getExpectedResult { input_file } {

    set result "PASS"
    set input_channel [open $input_file r]

    foreach line [split [read $input_channel] \n] {
        if {[regexp {^-- *MUST-FAIL:.*$} $line]} {
            set result "MUST-FAIL"
            break
        } elseif {[regexp {^-- *BUG:.*$} $line]} {
            set result "BUG"
            break
        }
    }
    return $result
}

#
# Tests each file provided by invoking the driver with the -fsyntax-only flag.
#
proc runTestsSyntaxOnly { test_inputs } {

    global srcroot objroot srcdir objdir toolroot

    foreach test_input $test_inputs {
        set expected_result [getExpectedResult $test_input]
        set retval [catch { exec $toolroot/driver -fsyntax-only $test_input } errmsg]

        if { $retval != 0 } {
            set error_code $::errorCode
            set error_class [lindex $error_code 0]
            set error_status [lindex $error_code 2]

            #
            # If the error class is CHILDSTATUS, use the true exit status from
            # the driver.  Otherwise, we have an exceptional condition
            # (segfault, assertion, etc).  The latter case always results in a
            # FAIL.
            #
            if { $error_class == "CHILDSTATUS" } {
                set retval $error_status
            } else {
                fail [concat $error_class $test_input]
                continue
            }
        }

        if { $expected_result == "MUST-FAIL" } {
            set retval [expr ! $retval]

            if { $retval == 0 } {
                pass $test_input
            } else {
                fail [concat $test_input $errmsg]
            }
        } elseif { $expected_result == "BUG" } {
            if { $retval == 0 } {
                xpass $test_input
            } else {
                xfail [concat $test_input $errmsg]
            }
        } else {
            if { $retval == 0 } {
                pass $test_input
            } else {
                fail [concat $test_input $errmsg]
            }
        }
    }
}

#
# Compiles and executes each file.  The entry point bust be Test.Run.
#
proc runCompiledTests { test_inputs } {

    global srcroot objroot srcdir objdir toolroot testroot

    foreach test_input $test_inputs {
        set test_prog $testroot/[file tail [file rootname $test_input]]
        set expected_result [getExpectedResult $test_input]
        set driver_invocation [list exec $toolroot/driver -e Test.Run \
                                   $test_input -o $test_prog]
        set retval [catch $driver_invocation errmsg]

        #
        # Compilation should always succeed.
        #
        if { $retval != 0 } {
            set error_code $::errorCode
            set error_class [lindex $error_code 0]
            fail [concat $error_class $driver_invocation $errmsg]
            continue
        }

        #
        # Run the test program and interpret its status wrt the expected result.
        #
        # If the error class is CHILDSTATUS, use the true exit status from the
        # test program.  Otherwise, we have an exceptional condition (segfault,
        # assertion, etc).  The latter case always results in a FAIL.
        #
        set retval [catch { exec $test_prog } errmsg]


        if { $retval != 0 } {
            set error_code $::errorCode
            set error_class [lindex $error_code 0]
            set error_status [lindex $error_code 2]

            #
            # If the error class is CHILDSTATUS, use the true exit status from
            # the test program.  Otherwise, we have an exceptional condition
            # (segfault, assertion, etc).  The latter case always results in a
            # FAIL.
            #
            if { $error_class == "CHILDSTATUS" } {
                set retval $error_status
            } else {
                fail [concat $error_class $test_prog]
                continue
            }
        }

        if { $expected_result == "MUST-FAIL" } {
            set retval [expr ! $retval]

            if { $retval == 0 } {
                pass $test_prog
            } else {
                fail [concat $test_prog $errmsg]
            }
        } elseif { $expected_result == "BUG" } {
            if { $retval == 0 } {
                xpass $test_prog
            } else {
                xfail [concat $test_prog $errmsg]
            }
        } else {
            if { $retval == 0 } {
                pass $test_prog
            } else {
                fail [concat $test_prog $errmsg]
            }
        }
    }
}