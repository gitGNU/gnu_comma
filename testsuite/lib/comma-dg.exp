##-- testsuite/lib/comma-dg.exp -----------------------------------*- Tcl -*--##
#
# This file is distributed under the MIT License.  See LICENSE.txt for details.
#
# Copyright (C) 2009-2010, Stephen Wilson
#
##----------------------------------------------------------------------------##

#
# getExpectedDiagnostics - Processes an input file searching for diagnostic
# markup.
#
# The following function processes a Comma source file and extracts all comments
# which identify expected diagnostics.  The format of these comments is very
# simple, and come in one of two forms:
#
#    -- EXPECTED-ERROR: <pattern>
#    -- EXPECTED-WARNING: <pattern>
#
# These two comments distinguish errors from warnings, and the supplied pattern
# is a regular expression to match against the actual compiler diagnostic.
#
# The location of these comments is significant.  If the comment is on a line of
# its own, a diagnostic is expected to be generated by the item on the following
# line.  If the comment is trailing, a diagnostic is expected to be generated by
# the item preceding the comment.  For example, if `No_Such_Name' is not defined
# then there are two ways to match the compiler diagnostic:
#
#    -- EXPECTED-ERROR: not visible
#    No_Such_Name;
#
#    No_Such_Name; -- EXPECTED-ERROR: not visible
#
# This function extracts all such comments a returns a list of lists.  Each
# sub-list contains three items: the line on which the diagnostic is expected,
# the kind of the diagnostic (either "ERROR" or "WARNING"), and the pattern to
# match.  In the comments that follows we refer to such sub-lists as "diagnostic
# triples".
#
proc getExpectedDiagnostics { input_file } {

    # Grep the input file for all expected warning and error lines.  Request
    # line numbers in the output.
    set regex "^.*-- EXPECTED-\\(WARNING\\|ERROR\\):"
    set grepcmd [list exec "grep" "-n" $regex $input_file]

    if { [catch $grepcmd matches] } {
        return
    }

    #
    # Process each match.  We are interested in the following items:
    #
    #   - The line number.
    #
    #   - If the comment is on a line of its own or is trailing.
    #
    #   - If we are expecting an error or warning.
    #
    #   - The match text itself.
    #
    set regex {^([0-9]+):(.*)-- EXPECTED-(WARNING|ERROR):(.*)$}
    set matches [split $matches "\n"]
    set result [list]
    foreach match $matches {
        if {![regexp $regex $match ignore line context kind target]} {
            error "Markup processing failed!"
        }

        #
        # If the context is non-empty, increment the line number.
        #
        if {[string trim $context] eq ""} {
            set line [expr $line + 1]
        }
        lappend result [list $line $kind $target]
    }
    return $result
}

#
# getCompilerDiagnostics - Generates a list of diagnostic triples corresponding
# to the output of the compiler.  This function ignores any notes generated by
# the compiler.
#
proc getCompilerDiagnostics { diagnostics } {
    set result [list]
    set regex {^.*:([0-9]+):[0-9]+: (warning|error):(.*)$}
    foreach line [split $diagnostics "\n"] {
        #
        # Look for lines of the form "file:line:column: kind: msg".  Ignore notes.
        #
        if {[regexp $regex $line ignore line kind target]} {
            set kind [string toupper $kind]
            if {$kind ne "NOTE"} {
                lappend result [list $line [string toupper $kind] $target]
            }
        }
    }
    return $result
}

#
# findDiagnostics - Searches a list diagnostic triples for all entries which
# contain the given line and kind.  Returns a list of all matching entries.
#
proc findDiagnostics {line kind candidates} {
    set result [list]
    foreach candidate $candidates {
        foreach {l k regex} $candidate { break }
        if {$line eq $l && $kind eq $k} {
            lappend result $regex
        }
    }
    return $result
}

#
# verifyDiagnostics - Given two lists of diagnostic triples, ensures that
# a triple exists in foundChecks that matches each triple in expectedChecks.
#
# There triple A matches a triple B if if both triples have the same line and
# kind, and if the target of A matches the target of B when applied as a regular
# expression.
#
# Note that foundChecks can be a super-set of expectedChecks.
#
# Returns 0 if a any match fails and 1 if all triples match.
#
proc verifyDiagnostics { expectedChecks foundChecks } {

    #
    # Ensure that we found the required diagnostics.
    #
    foreach expectedCheck $expectedChecks {
        foreach {line kind regex} $expectedCheck { break }
        set matches [findDiagnostics $line $kind $foundChecks]

        if {![llength $matches]} {
            return 0
        }

        foreach target $matches {
            if {![regexp [string trim $regex] $target]} {
                return 0
            }
        }
    }
    return 1;
}

#
# Tests each file provided by invoking the driver with the -fsyntax-only flag,
# and verifying any expected diagnostics.
#
proc runTestsSyntaxOnly { test_inputs } {

    global srcroot objroot srcdir objdir toolroot

    foreach test_input $test_inputs {
        set retval [catch { exec $toolroot/driver -fsyntax-only $test_input } msg]

        if { $retval != 0 } {
            set error_code $::errorCode
            set error_class [lindex $error_code 0]
            set error_status [lindex $error_code 2]

            if { $error_class == "NONE" } {
                # When the error class is NONE then the exit status from the
                # driver was zero but we printed something to stderr.  This
                # happens for warnings.  TCL does not set the exit code field in
                # this case.
                set retval 0
            } elseif { $error_class == "CHILDSTATUS" } {
                # If the error class is CHILDSTATUS use the true exit status
                # from the driver.
                set retval $error_status
            } else {
                # Otherwise, we have an exceptional condition (segfault,
                # assertion, etc).  The latter case always results in a FAIL.
                fail [concat $error_class $test_input]
                continue
            }
        }

        set expectedChecks [getExpectedDiagnostics $test_input]
        set foundChecks [getCompilerDiagnostics $msg]

        #
        # If the exit status is non-zero then there must be at least one
        # diagnostic check expected.
        #
        if {$retval != 0 && [llength $expectedChecks] == 0} {
            fail [concat $test_input $msg]
        }

        #
        # Verify the diagnostics.  We do this even for a zero exit status since
        # the compiler might be missing a warning or error.
        #
        if {[verifyDiagnostics $expectedChecks $foundChecks]} {
            pass $test_input
        } else {
            fail [concat $test_input "Diagnostic verification failed."]
        }
    }
}

#
# Compiles and executes each file.  The entry point must be Test.Run.
#
proc runCompiledTests { test_inputs } {

    global srcroot objroot srcdir objdir toolroot testroot

    foreach test_input $test_inputs {
        set test_prog $testroot/[file tail [file rootname $test_input]]
        set driver_invocation [list exec $toolroot/driver -e Test.Run \
                                   $test_input -o $test_prog -d $testroot]
        set retval [catch $driver_invocation errmsg]

        #
        # Compilation should always succeed, perhaps with warnings.
        #
        if { $retval != 0 } {
            set error_code $::errorCode
            set error_class [lindex $error_code 0]

            if { $error_class != "NONE" } {
                fail [concat $error_class $driver_invocation $errmsg]
                continue
            }
        }

        #
        # Exectue the test program.
        #
        set retval [catch { exec $test_prog } errmsg]

        if { $retval != 0 } {
            set error_code $::errorCode
            set error_class [lindex $error_code 0]
            set error_status [lindex $error_code 2]

            #
            # If the error class is CHILDSTATUS or NONE use the true exit status
            # from the test program.  Otherwise, we have an exceptional
            # condition (segfault, assertion, etc).  The latter case always
            # results in a FAIL.
            #
            if { $error_class == "NONE" } {
                set retval 0
            } elseif { $error_class == "CHILDSTATUS" } {
                set retval $error_status
            } else {
                fail [concat $error_class $test_prog]
                continue
            }
        }

        if { $retval == 0 } {
            pass $test_prog
        } else {
            fail [concat $test_prog $errmsg]
        }
    }
}
